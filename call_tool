#!/bin/bash

# Tool execution script for Gemini CLI
# Usage: call_tool <function_name>
# Reads function arguments as JSON from stdin
# Returns function output as JSON on stdout

FUNCTION_NAME="$1"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/vm_config.json"
VENV_DIR="$SCRIPT_DIR/.vnc_env"

# Setup virtual environment if it doesn't exist
if [ ! -f "$VENV_DIR/bin/python" ]; then
    # Create venv and install dependencies
    echo '{"status": "initializing", "message": "Creating virtual environment..."}' >&2
    python3 -m venv "$VENV_DIR" >/dev/null 2>&1
    
    # Set pip cache and temp directories to use our partition
    export PIP_CACHE_DIR="$SCRIPT_DIR/.pip_cache"
    export TMPDIR="$SCRIPT_DIR/.tmp"
    mkdir -p "$PIP_CACHE_DIR" "$TMPDIR"
    
    # Install ALL required dependencies for complete functionality:
    # - vncdotool: VNC client for remote desktop control
    # - pillow: Image processing for screenshots
    # - requests: HTTP client for API calls  
    # - python-dotenv: Environment variable loading
    # - gradio-client: Gradio API client (if needed)
    # - openai: OpenAI API client 
    # - scikit-learn: Machine learning (DBSCAN clustering for window detection)
    # - numpy: Numerical computing (required by scikit-learn)
    # - replicate: Replicate API client for OmniParser
    echo '{"status": "installing", "message": "Installing core dependencies..."}' >&2
    "$VENV_DIR/bin/pip" install --upgrade pip --quiet
    if ! "$VENV_DIR/bin/pip" install vncdotool pillow requests python-dotenv gradio-client openai scikit-learn numpy replicate --quiet; then
        echo '{"success": false, "error": "Failed to install core dependencies. Please run: pip install vncdotool pillow requests python-dotenv gradio-client openai scikit-learn numpy replicate"}'
        exit 1
    fi
    
    # Install OmniParser/local vision model dependencies (large downloads):
    # Install in stages to avoid conflicts
    echo '{"status": "installing", "message": "Installing OmniParser dependencies (this may take several minutes)..."}' >&2
    
    # Stage 1: Core PyTorch
    "$VENV_DIR/bin/pip" install torch torchvision --quiet
    
    # Stage 2: Transformers with specific version for Florence2 compatibility
    # First upgrade pip to get better wheel support
    "$VENV_DIR/bin/pip" install --upgrade pip --quiet
    # Try version 4.36 which should have better wheel support
    "$VENV_DIR/bin/pip" install transformers==4.36.0 --quiet || \
    "$VENV_DIR/bin/pip" install transformers --quiet
    
    # Stage 3: Other ML dependencies  
    "$VENV_DIR/bin/pip" install accelerate timm ultralytics einops --quiet
    
    # Stage 3b: Try to install flash_attn (optional but needed for some models)
    # This often fails due to CUDA/compilation issues, so make it optional
    echo '{"status": "installing", "message": "Attempting to install flash_attn (optional)..."}' >&2
    if "$VENV_DIR/bin/pip" install flash-attn --no-build-isolation --quiet 2>/dev/null; then
        echo '{"status": "info", "message": "flash_attn installed successfully"}' >&2
    else
        echo '{"status": "warning", "message": "flash_attn installation failed, will use fallback"}' >&2
    fi
    
    # Stage 4: OCR libraries
    "$VENV_DIR/bin/pip" install easyocr supervision paddlepaddle paddleocr --quiet
    
    # Check if torch is installed (critical dependency)
    if "$VENV_DIR/bin/python" -c "import torch" 2>/dev/null; then
        echo '{"status": "complete", "message": "All dependencies installed successfully"}' >&2
    else
        echo '{"status": "warning", "message": "Some OmniParser dependencies failed to install, falling back to API-only functionality"}' >&2
    fi
    
    # Clean up temp directories
    rm -rf "$TMPDIR" "$PIP_CACHE_DIR"
fi

# Use the venv Python with suppressed transformers warnings
PYTHON="$VENV_DIR/bin/python"
export TRANSFORMERS_VERBOSITY=error
export HF_HUB_DISABLE_EXPERIMENTAL_WARNING=1
export HF_HUB_DISABLE_TELEMETRY=1

# Read JSON arguments from stdin, provide default if empty
ARGS=$(cat)
if [ -z "$ARGS" ]; then
    ARGS="{}"
fi

# Function to get VNC connection details from vm_target
get_vnc_connection() {
    local vm_target="$1"
    "$PYTHON" -c "
import json
config_file = '$CONFIG_FILE'
with open(config_file, 'r') as f:
    config = json.load(f)
    target = '$vm_target' or config.get('default_target', 'local')
    vm_info = config['vm_targets'].get(target, config['vm_targets']['local'])
    print(f\"{vm_info['host']}:{vm_info['vnc_port']}\")
"
}

case "$FUNCTION_NAME" in
    "get_screenshot_description")
        # Extract vm_target from JSON args
        VM_TARGET=$(echo "$ARGS" | "$PYTHON" -c "import json, sys; data=json.load(sys.stdin); print(data.get('vm_target', 'local'))")
        VNC_ADDRESS=$(get_vnc_connection "$VM_TARGET")
        
        # Parse host and port
        VNC_HOST=$(echo "$VNC_ADDRESS" | cut -d: -f1)
        VNC_PORT=$(echo "$VNC_ADDRESS" | cut -d: -f2)
        
        # Execute the screenshot analysis 
        "$PYTHON" "$SCRIPT_DIR/vnc_tools.py" screenshot "$VNC_HOST" "$VNC_PORT" "$VM_TARGET"
        ;;
        
    "send_mouse_clicks")
        # Extract parameters from JSON args
        VM_TARGET=$(echo "$ARGS" | "$PYTHON" -c "import json, sys; data=json.load(sys.stdin); print(data.get('vm_target', 'local'))")
        VNC_ADDRESS=$(get_vnc_connection "$VM_TARGET")
        
        # Parse host and port
        VNC_HOST=$(echo "$VNC_ADDRESS" | cut -d: -f1)
        VNC_PORT=$(echo "$VNC_ADDRESS" | cut -d: -f2)
        
        # Pass the clicks JSON to Python script
        echo "$ARGS" | "$PYTHON" "$SCRIPT_DIR/vnc_tools.py" mouse "$VNC_HOST" "$VNC_PORT" "$VM_TARGET"
        ;;
        
    "send_keyboard")
        # Pass the JSON from ARGS to Python stdin
        echo "$ARGS" | "$PYTHON" -W ignore "$SCRIPT_DIR/vnc_tools.py" keyboard --stdin-json
        EXIT_CODE=$?
        
        # Handle errors
        if [ $EXIT_CODE -ne 0 ]; then
            # Python script already printed error JSON, just exit with error code
            exit $EXIT_CODE
        fi
        ;;
        
    *)
        echo "{\"success\": false, \"error\": \"Unknown function: $FUNCTION_NAME\"}"
        exit 1
        ;;
esac